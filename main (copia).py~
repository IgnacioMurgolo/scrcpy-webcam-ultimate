import customtkinter as ctk
import subprocess
import os
import shutil
import threading
import re
from colorama import Fore, init

init(autoreset=True)

# Ajust치 esto si tu ruta es distinta
SCRCPY_PATH = os.path.expanduser("~/Documents/scrcpy-linux-x86_64-v3.3.4/scrcpy")

# --- L칍GICA DE SISTEMA ---

def check_dependencies():
    return shutil.which("adb") is not None and os.path.exists(SCRCPY_PATH)

def get_device_info():
    try:
        res = subprocess.run("adb shell getprop ro.product.model", shell=True, capture_output=True, text=True, timeout=2)
        return res.stdout.strip() if res.stdout.strip() else "No detectado"
    except: return "Error ADB"

def get_best_encoder():
    try:
        res = subprocess.run(f"{SCRCPY_PATH} --list-encoders", shell=True, capture_output=True, text=True, timeout=5)
        # Priorizamos el hardware de Qualcomm para tu Whyred
        if "OMX.qcom.video.encoder.avc" in res.stdout:
            return "OMX.qcom.video.encoder.avc"
        return "c2.android.avc.encoder"
    except: return "c2.android.avc.encoder"

def get_camera_list():
    """Escanea las lentes disponibles."""
    print(f"{Fore.CYAN}[*] Escaneando lentes disponibles...")
    try:
        cmd = f"{SCRCPY_PATH} --list-cameras"
        res = subprocess.run(cmd, shell=True, capture_output=True, text=True)
        
        cameras = []
        lines = res.stdout.split('\n') + res.stderr.split('\n')
        
        for line in lines:
            if "camera-id=" in line:
                match = re.search(r'camera-id=(\d+)', line)
                if match:
                    cam_id = match.group(1)
                    label = f"Lente ID {cam_id}"
                    if cam_id == "0": label += " (Trasera Principal)"
                    elif cam_id == "1": label += " (Frontal Selfie)"
                    elif cam_id == "2": label += " (Gran Ang./Macro)"
                    else: label += " (Auxiliar)"
                    cameras.append(label)
        
        if not cameras: return ["Lente ID 0 (Trasera)", "Lente ID 1 (Frontal)"]
        return sorted(list(set(cameras)))

    except Exception:
        return ["Lente ID 0 (Trasera)", "Lente ID 1 (Frontal)"]

def setup_v4l2(node=10):
    os.system("sudo modprobe -r v4l2loopback 2>/dev/null")
    os.system(f"sudo modprobe v4l2loopback card_label='Webcam-Pro' exclusive_caps=1 video_nr={node}")
    return os.path.exists(f"/dev/video{node}")

# --- INTERFAZ GR츼FICA ---

class WebcamApp(ctk.CTk):
    def __init__(self):
        super().__init__()
        self.title("Scrcpy Webcam Ultimate")
        self.geometry("400x600")
        ctk.set_appearance_mode("dark")
        
        self.process = None

        # Datos iniciales
        self.modelo = get_device_info()
        self.encoder = get_best_encoder()
        self.lista_lentes = get_camera_list()

        # UI
        ctk.CTkLabel(self, text="Webcam Control Center", font=("Roboto", 22, "bold")).pack(pady=15)
        ctk.CTkLabel(self, text=f"游님 {self.modelo}", text_color="#3498db").pack()
        
        # Selecci칩n de Lente
        ctk.CTkLabel(self, text="Lente / C치mara:").pack(pady=(20, 5))
        self.cam_opt = ctk.CTkOptionMenu(self, values=self.lista_lentes)
        self.cam_opt.pack(pady=5)
        
        # Resoluci칩n (Sacamos 480p)
        ctk.CTkLabel(self, text="Calidad:").pack(pady=(15, 5))
        self.res_opt = ctk.CTkSegmentedButton(self, values=["720p", "1080p"], command=self.ajustar_bitrate_sugerido)
        self.res_opt.set("720p")
        self.res_opt.pack(pady=5)
        
        # Bitrate
        self.lbl_bitrate = ctk.CTkLabel(self, text="Bitrate: 8 Mbps")
        self.lbl_bitrate.pack(pady=(15, 5))
        self.bit_slider = ctk.CTkSlider(self, from_=2, to=16, number_of_steps=14, command=self.actualizar_label)
        self.bit_slider.set(8)
        self.bit_slider.pack(pady=5)
        
        # Bot칩n Principal
        self.btn = ctk.CTkButton(self, text="INICIAR STREAM", fg_color="#2ecc71", 
                                 font=("Roboto", 14, "bold"), height=45, command=self.toggle_camara)
        self.btn.pack(pady=40, padx=20, fill="x")

        self.status = ctk.CTkLabel(self, text="Listo", text_color="gray")
        self.status.pack(side="bottom", pady=10)

    def actualizar_label(self, value):
        self.lbl_bitrate.configure(text=f"Bitrate: {int(value)} Mbps")

    def ajustar_bitrate_sugerido(self, value):
        if value == "1080p":
            self.bit_slider.set(5) # Bajamos bitrate para evitar lag verde
            self.lbl_bitrate.configure(text="Bitrate: 5 Mbps (Recomendado)")
        else:
            self.bit_slider.set(8)
            self.lbl_bitrate.configure(text="Bitrate: 8 Mbps")

    def toggle_camara(self):
        if "INICIAR" in self.btn.cget("text"):
            self.thread = threading.Thread(target=self.lanzar_worker, daemon=True)
            self.thread.start()
            self.btn.configure(text="DETENER STREAM", fg_color="#e74c3c")
            self.status.configure(text="游댮 EN VIVO - /dev/video10", text_color="#e74c3c")
        else:
            self.detener()

    def lanzar_worker(self):
        # Extraemos solo el n칰mero del ID
        seleccion = self.cam_opt.get()
        cam_id = re.search(r'ID (\d+)', seleccion).group(1)
        
        res_text = self.res_opt.get()
        # Solo mapeamos HD y Full HD
        res_map = {"720p": "1280x720", "1080p": "1920x1080"}
        res = res_map[res_text]
        bit = int(self.bit_slider.get())
        
        if setup_v4l2(10):
            cmd = [
                SCRCPY_PATH, 
                "--video-source=camera", 
                f"--camera-id={cam_id}",
                f"--camera-size={res}", 
                f"--video-encoder={self.encoder}",
                f"--video-bit-rate={bit}M", 
                "--v4l2-sink=/dev/video10",
                "--no-audio", 
                "--video-buffer=0", 
                "--no-video-playback"
            ]
            
            try:
                self.process = subprocess.Popen(cmd)
                self.process.wait()
            except Exception as e:
                print(f"Error: {e}")
            finally:
                self.btn.configure(text="INICIAR STREAM", fg_color="#2ecc71")
                self.status.configure(text="Stream finalizado", text_color="gray")

    def detener(self):
        if self.process:
            self.process.terminate()
            self.process = None
        os.system("sudo modprobe -r v4l2loopback 2>/dev/null")

if __name__ == "__main__":
    if check_dependencies():
        app = WebcamApp()
        app.mainloop()
    else:
        print(f"{Fore.RED}Error: Faltan dependencias.")
